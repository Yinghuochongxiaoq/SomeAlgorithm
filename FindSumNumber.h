/*
题目：输入一个数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字。要求时间复杂度是 O(n)。如果有多对数字的和等于输入的数字，输出任意一对即可。例如输入数组 1、2、4、7、11、15 和数字 15。由于 4+11=15，因此输出 4 和 11

1. 直接穷举，从数组中任意选取两个数，判定它们的和是否为输入的那个数字。此举
复杂度为 O（N^2）。很显然，我们要寻找效率更高的解法。
2. 题目相当于，对每个 a[i]，然后查找判断 sum-a[i]是否也在原始序列中，每一次要查
找的时间都要花费为 O（N），这样下来，最终找到两个数还是需要 O（N^2）的复
杂度。那如何提高查找判断的速度列?对了，二分查找，将原来 O（N）的查找时间
提高到 O （logN） ， 这样对于 N 个 a[i]， 都要花 logN 的时间去查找相对应的 sum-a[i]
是否在原始序列中，总的时间复杂度已降为 O（N*logN），且空间复杂度为 O（1）。
（如果有序，直接二分 O（N*logN），如果无序，先排序后二分，复杂度同样为 O
（N*logN+N*logN）=O（N*logN），空间总为 O（1））。
3. 有没有更好的办法列?咱们可以依据上述思路 2 的思想，a[i]在序列中，如果
a[i]+a[k]=sum 的话，那么 sum-a[i]（a[k]）也必然在序列中，，举个例子，如下：
原始序列：1、 2、 4、 7、11、15     用输入数字 15 减一下各个数，得到对应的
序列为：
对应序列：14、13、11、8、4、 0
第一个数组以一指针 i 从数组最左端开始向右扫描，第二个数组以一指针 j 从数组
最右端开始向左扫描，如果下面出现了和上面一样的数，即 a[*i]=a[*j]，就找出这俩
个数来了。如上，i，j 最终在第一个，和第二个序列中找到了相同的数 4 和 11，，
所以符合条件的两个数，即为 4+11=15。怎么样，两端同时查找，时间复杂度瞬间
缩短到了 O（N），但却同时需要 O（N）的空间存储第二个数组（@飞羽：要达
到 O(N)的复杂度，第一个数组以一指针 i 从数组最左端开始向右扫描，
第二个数组以一指针 j 从数组最右端开始向左扫描，首先初始 i 指向元素
1，j 指向元素 0，谁指的元素小，谁先移动，由于 1（i）>0（j），所以 i
不动，j 向左移动。然后 j 移动到元素 4 发现大于元素 1，故而停止移动 j，
开始移动 i，直到 i 指向 4，这时,i 指向的元素与 j 指向的元素相等，故而
判断 4 是满足条件的第一个数；然后同时移动 i,j 再进行判断，直到它们
到达边界）。
4. 当然，你还可以构造 hash 表，正如编程之美上的所述，给定一个数字，根据 hash
映射查找另一个数字是否也在数组中，只需用 O（1）的时间，这样的话，总体的算
法通上述思路 3 一样，也能降到 O（N），但有个缺陷，就是构造 hash 额外增加
了 O（N）的空间，此点同上述思路 3。不过，空间换时间，仍不失为在时间要求
较严格的情况下的一种好办法。
5. 如果数组是无序的，先排序（n*logn），然后用两个指针 i，j，各自指向数组的首尾
两端， 令i=0， j=n-1， 然后i++， j--， 逐次判断a[i]+a[j]?=sum， 如果某一刻a[i]+a[j]>sum，
则要想办法让 sum 的值减小，所以此刻 i 不动，j--，如果某一刻 a[i]+a[j]<sum，则
要想办法让 sum 的值增大，所以此刻 i++，j 不动。所以，数组无序的时候，时间复
杂度最终为 O（n*logn+n）=O（n*logn），若原数组是有序的，则不需要事先的排
序，直接 O（n）搞定，且空间复杂度还是 O（1），此思路是相对于上述所有思路
的一种改进。（如果有序，直接两个指针两端扫描，时间 O（N），如果无序，先
排序后两端扫描，时间 O（N*logN+N）=O（N*logN），空间始终都为 O（1））。
（与上述思路 2 相比，排序后的时间开销由之前的二分的 n*logn 降到了扫描的 O
（N））。
*/
class FindSumNumber
{
public:
	FindSumNumber();
	~FindSumNumber();
	void DealFindSum();
};

//返回类
class Pair
{
public:
	int Begin;
	int End;
	Pair();
	Pair(int begin,int end);
};

